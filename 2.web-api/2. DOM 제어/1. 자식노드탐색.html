<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>



</head>
<body>
    
    <ul id="fruits">
        <li class="apple">사과</li>
        <li class="banana">바나나</li>
        <li class="grape">포도</li>
    </ul>

    <div class="test">
        <!-- <div></div> -->
    </div>

    <script>
        console.log(document); // -> root node
        console.log('------------');
        console.log(document.documentElement);
        console.log('---------------');
        console.log(document.body);           // body까지는 공식 있고, 그다음부터는 1.dom기초 에서 배운대로.
        console.log('======================================================');
        // 노드 탐색의 기점이 되는 요소 취득
        const $fruits = document.getElementById('fruits');
        // childNodes : 기준노드의 모든 자식노드를 탐색, 텍스트 노드 포함
        //const $childs = $fruits.childNodes;
        //console.log($childs);  // -> 7개 나옴. data : "/n               " -> 들여쓰기랑 줄바꿈까지 다 자식으로 잡힘.
        // => childNodes는 안쓰는게 나음.
        
        // children : 기준노드의 모든 자식노드를 탐색, 텍스트 노드 제외
        const $childs = $fruits.children;
        console.log($childs);

        //console.log($fruits.firstChild); // -> #text가 나옴. 쓰지말기. (lastChild도)
        console.log($fruits.firstElementChild);
        console.log($fruits.lastElementChild);

        // 기준 노드의 자식 노드 존재여부 확인
        const $test = document.querySelector('.test');
        console.log($test.hasChildNodes()); // 함수라 () 붙이고, 물어봄 $test에 자식 있냐. ->true뜸
        console.log($test.childNodes); // -> 있다고 나옴. 공백.
        // => 공백 테스트 존재시 텍스트노드를 자식으로 보고 true를 리턴해버림. 안씀

        // 공백 텍스트를 제외한 자식요소노드 존재 여부 확인 ($test.hasChildNodes() 대신 쓰는거)
        console.log(!!$test.children.length);

        // $test.children.length -> 3 : 3은 논리가 아님. 근데 ! 붙어서 논리값으로 바뀜(truthy), 그 값의 반대. ! 한번 더 붙여서 반대된거 복귀
    </script>


</body>
</html>